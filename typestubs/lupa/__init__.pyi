from typing import Any, Optional, Callable, Tuple, Dict

LUA_MAXINTEGER: int
LUA_MININTEGER: int
LUA_VERSION: int

class LuaError(Exception): ...
class LuaSyntaxError(LuaError): ...
class LuaMemoryError(LuaError, MemoryError): ...
# class _PyProtocolWrapper(object):
#     _type_flags: int

def as_attrgetter(obj: Any) -> Any: ...
def as_itemgetter(obj: Any) -> Any: ...

def lua_type(obj: Any) -> Optional[str]: ...
def unpack_lua_table(func: Callable) -> Callable: ...
def unpack_lua_table_method(meth: Callable) -> Callable: ...

class LuaRuntime():
    encoding: str = 'UTF-8'
    source_encoding: Optional[str] = None
    attribute_filter: Optional[Callable] = None
    attribute_handlers: Optional[Callable] = None
    register_eval: bool = True
    unpack_returned_tuples: bool = False
    register_builtins: bool = True
    overflow_handler: Optional[Callable] = None
    max_memory: Optional[int]

    def __dealloc__(self) -> None: ...
    def get_max_memory(self, total: bool = False) -> Optional[int]: ...
    def get_memory_used(self, total: bool = False) -> Optional[int]: ...
    @property
    def lua_version(self) -> int: ...
    @property
    def lua_implementation(self) -> str: ...
    def eval(self, lua_code: str, *args: Any) -> Any: ...
    def execute(self, lua_code: str, *args: Any) -> Any: ...
    def compile(self, lua_code:str) -> Any: ...
    def require(self, modulename: str) -> None: ...
    def globals(self) -> Optional[dict]: ...
    def table(self, *args: Any, **kwargs: Any) -> Any: ...
    def table_from(self, *args: Any) -> Any: ...
    def set_max_memory(self, max_memory: int, total: bool = False) -> None: ...
    def set_overflow_handler(self, overflow_handler: Callable) -> None: ...



# Names in __all__ with no definition:
#   LUA_MAXINTEGER
#   LUA_MININTEGER
#   LUA_VERSION
#   LuaError
#   LuaMemoryError
#   LuaRuntime
#   LuaSyntaxError
#   as_attrgetter
#   as_itemgetter
#   lua_type
#   unpacks_lua_table
#   unpacks_lua_table_method
